Redis Streams consumer
Kafka producer + consumer,
Async version with Kafka
Fraud detection logic
Duplicate click prevention with Redis
Edge-level click handling (Nginx + Lua)
show me all these 

Excellent ‚Äî this is **real ad-tech / high-scale system design**.
I‚Äôll show you **how all of these fit together**, with **clear architecture + minimal but real code** so you understand **what runs where and why**.

We‚Äôll build this in **layers**, exactly like production systems (Google Ads / Meta).

---

# üèóÔ∏è HIGH-LEVEL ARCHITECTURE

```
[ User ]
   |
   v
[ NGINX + Lua ]  (edge filtering, dedupe, ultra-fast)
   |
   v
[ Click API (Spring Boot) ]
   |
   ‚îú‚îÄ‚îÄ Redis (dedupe + rate limit)
   ‚îú‚îÄ‚îÄ Kafka Producer (async)
   |
   v
[ Kafka Topic: ad-clicks ]
   |
   ‚îú‚îÄ‚îÄ Fraud Detection Consumer
   ‚îú‚îÄ‚îÄ Analytics Consumer
   ‚îî‚îÄ‚îÄ Redis Stream Consumer (optional)
```

---

# 1Ô∏è‚É£ Duplicate Click Prevention (Redis ‚Äì FIRST LINE OF DEFENSE)

### Goal

> Same user clicking same ad within 1 minute ‚Üí **count only once**

### Redis key

```
click:dedupe:{userIp}:{adId}
```

### Logic

```java
Boolean isFirstClick = redisTemplate.opsForValue()
    .setIfAbsent(key, "1", 60, TimeUnit.SECONDS);

if (!Boolean.TRUE.equals(isFirstClick)) {
    // Duplicate click ‚Üí ignore or flag
}
```

‚úÖ O(1)
‚úÖ Distributed
‚úÖ Extremely fast

---

# 2Ô∏è‚É£ Kafka (ASYNC Click Processing)

## Kafka Topic

```
ad-clicks
```

---

## Kafka Producer (Spring Boot)

### Dependency

```xml
<dependency>
  <groupId>org.springframework.kafka</groupId>
  <artifactId>spring-kafka</artifactId>
</dependency>
```

### Producer Code

```java
@Service
public class ClickEventProducer {

    @Autowired
    private KafkaTemplate<String, ClickEvent> kafkaTemplate;

    public void sendClick(ClickEvent event) {
        kafkaTemplate.send("ad-clicks", event.getUserIp(), event);
    }
}
```

### ClickEvent DTO

```java
public class ClickEvent {
    public Long adId;
    public Long campaignId;
    public String userIp;
    public String userAgent;
    public long timestamp;
}
```

---

## Controller (ASYNC)

```java
producer.sendClick(clickEvent);
return ResponseEntity.status(302).location(URI.create(url)).build();
```

‚ö° User is redirected immediately
‚ö° DB work is async

---

# 3Ô∏è‚É£ Kafka Consumer (Fraud Detection)

## Fraud patterns

* Too many clicks from same IP
* Multiple ads clicked in short time
* Same user-agent across many IPs

---

### Consumer Code

```java
@KafkaListener(topics = "ad-clicks", groupId = "fraud-detector")
public void detectFraud(ClickEvent event) {

    String key = "fraud:ip:" + event.userIp;
    Long count = redisTemplate.opsForValue().increment(key);

    if (count == 1) {
        redisTemplate.expire(key, 10, TimeUnit.MINUTES);
    }

    if (count > 100) {
        // Mark IP as fraudulent
        redisTemplate.opsForSet().add("fraud:ips", event.userIp);
    }
}
```

---

# 4Ô∏è‚É£ Redis Streams Consumer (Alternative to Kafka)

Used when:

* Kafka is too heavy
* You want Redis-only infra

---

### Producer

```java
redisTemplate.opsForStream().add(
    StreamRecords.newRecord()
        .ofObject(clickEvent)
        .withStreamKey("click-stream")
);
```

### Consumer

```java
@Scheduled(fixedDelay = 1000)
public void consume() {
    List<MapRecord<String, Object, Object>> messages =
        redisTemplate.opsForStream().read(
            Consumer.from("group1", "consumer1"),
            StreamReadOptions.empty().count(10),
            StreamOffset.create("click-stream", ReadOffset.lastConsumed())
        );

    // process messages
}
```

---

# 5Ô∏è‚É£ Edge-Level Click Handling (NGINX + LUA) üöÄ

This is **how big ad networks survive traffic spikes**.

---

## NGINX Lua Script

```lua
local redis = require "resty.redis"
local red = redis:new()

red:connect("127.0.0.1", 6379)

local ip = ngx.var.remote_addr
local adId = ngx.var.arg_adId

local key = "edge:click:" .. ip .. ":" .. adId

local exists = red:get(key)
if exists ~= ngx.null then
    return ngx.exit(429)
end

red:setex(key, 60, "1")

-- Forward to backend
```

### Benefits

* üî• Drops bad traffic **before Spring Boot**
* üî• Handles millions of QPS
* üî• Saves backend cost

---

# 6Ô∏è‚É£ Sliding Window Rate Limiting (User = 1 click/min)

Already implemented, but now layered:

| Layer          | Purpose             |
| -------------- | ------------------- |
| NGINX          | First dedupe        |
| Redis          | Accurate dedupe     |
| Kafka          | Async processing    |
| Fraud Consumer | Long-term detection |

---

# 7Ô∏è‚É£ COMPLETE FLOW (IMPORTANT)

```
User clicks
 ‚Üì
NGINX Lua ‚Üí duplicate? DROP
 ‚Üì
Spring Filter ‚Üí sliding window
 ‚Üì
Redis dedupe ‚Üí prevent double count
 ‚Üì
Kafka ‚Üí async event
 ‚Üì
Redirect user
 ‚Üì
Kafka Consumer ‚Üí fraud + analytics
```

---

# 8Ô∏è‚É£ Why this is production-grade

‚úÖ Low latency (sub-10ms)
‚úÖ Horizontally scalable
‚úÖ Async DB writes
‚úÖ Multi-layer fraud protection
‚úÖ Edge + backend enforcement

---

# 9Ô∏è‚É£ Interview-ready explanation (MEMORIZE)

> ‚ÄúClicks are handled at the edge using NGINX Lua for fast deduplication. The backend applies Redis-based sliding window limits and publishes click events to Kafka. Consumers asynchronously perform fraud detection and analytics, ensuring low latency redirects while maintaining accurate click counts.‚Äù

---

# üî• What I can show next (choose)

1Ô∏è‚É£ Full **Docker setup** (Redis + Kafka + Spring)
2Ô∏è‚É£ **System design diagram** (interview-ready)
3Ô∏è‚É£ **Exactly-once click counting**
4Ô∏è‚É£ **Real ad-tech fraud rules**
5Ô∏è‚É£ **How Google Ads does this**

Just tell me which one üëá


check : 
Different limits per ad

Per-user + global limits combined

Sliding window implemented with Redis sorted sets